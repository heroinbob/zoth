defmodule Zoth.AccessGrants.AccessGrantTest do
  use Zoth.TestCase

  alias Dummy.OauthAccessGrants.OauthAccessGrant
  alias Dummy.Repo
  alias Ecto.Changeset
  alias Zoth.AccessGrants.AccessGrant
  alias Zoth.Test.Fixtures
  alias Zoth.Test.PKCE

  describe "changeset/4" do
    test "returns a valid changeset with a token and the default app scope when the attrs are valid" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, otp_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert grant.application == app
      assert grant.expires_in == attrs.expires_in
      assert grant.redirect_uri == attrs.redirect_uri
      assert grant.resource_owner == user
      assert grant.scopes == "public"
      assert is_binary(grant.token)
    end

    test "requires expires_in to be an integer" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        expires_in: "900",
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, otp_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert grant.expires_in == 900

      attrs = %{
        expires_in: "nine-hundred-seconds",
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, otp_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert {"is invalid", _} = errors[:expires_in]
    end

    test "requires redirect_uri to be a string" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        expires_in: 900,
        redirect_uri: nil
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, opt_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:redirect_uri]

      attrs = %{
        expires_in: 900,
        redirect_uri: ""
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, opt_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:redirect_uri]

      attrs = %{
        expires_in: 900,
        redirect_uri: :something
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, opt_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert {"is invalid", _} = errors[:redirect_uri]
    end

    test "requires token to be a unique string" do
      %{application: app, resource_owner: user} =
        grant = Fixtures.insert(:access_grant, token: "ima-token", redirect_uri: "redirect-uri")

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      # Token is generated by the code and is not castable. Let's force it.
      assert {:error, %Changeset{errors: errors}} =
               AccessGrant.changeset(
                 %OauthAccessGrant{
                   application: app,
                   resource_owner: user
                 },
                 attrs,
                 app,
                 otp_app: :zoth
               )
               |> Changeset.put_change(:token, grant.token)
               |> Repo.insert()

      assert {"has already been taken", _} = errors[:token]
    end

    test "accepts scopes and requires them to be permitted by the application" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
        scopes: "read write"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, opt_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert grant.scopes == "read write"

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
        scopes: "foo"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app, opt_app: :zoth)
               |> Changeset.apply_action(:validate)

      assert {~s(not in permitted scopes list: "public read write"), _} = errors[:scopes]
    end
  end

  describe "changeset/2 when PKCE is required" do
    test "requires code_challenge and code_challenge_method when PKCE is required" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app,
                 opt_app: :zoth,
                 pkce: :all_methods
               )
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:code_challenge]
      assert {"can't be blank", _} = errors[:code_challenge_method]
    end

    test "accepts all supported challenge methods" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)
      challenge = PKCE.generate_code_challenge()

      for {method, query_param} <- [{:plain, "plain"}, {:s256, "S256"}] do
        attrs = %{
          code_challenge: challenge,
          code_challenge_method: query_param,
          expires_in: 900,
          redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
        }

        assert {:ok, %OauthAccessGrant{} = grant} =
                 %OauthAccessGrant{
                   application: app,
                   resource_owner: user
                 }
                 |> AccessGrant.changeset(attrs, app,
                   opt_app: :zoth,
                   pkce: :all_methods
                 )
                 |> Changeset.apply_action(:validate)

        assert grant.code_challenge == challenge
        assert grant.code_challenge_method == method
      end
    end

    test "rejects unsupported challenge methods" do
      app = Fixtures.insert(:application)
      user = Fixtures.insert(:user)

      attrs = %{
        code_challenge: PKCE.generate_code_challenge(),
        code_challenge_method: "not-a-real-method",
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, app,
                 opt_app: :zoth,
                 pkce: :all_methods
               )
               |> Changeset.apply_action(:validate)

      refute Keyword.has_key?(errors, :code_challenge)
      assert {"is invalid", _} = errors[:code_challenge_method]
    end

    test "requires the open_id_nonce to be unique" do
      challenge = PKCE.generate_code_challenge()

      %{application: app} =
        Fixtures.insert(
          :access_grant,
          code_challenge: challenge,
          code_challenge_method: :s256
        )

      assert {:error, %Changeset{errors: errors}} =
               :access_grant
               |> Fixtures.build(code_challenge: nil)
               |> AccessGrant.changeset(
                 %{
                   code_challenge: challenge,
                   code_challenge_method: "S256"
                 },
                 app,
                 opt_app: :zoth,
                 pkce: :all_methods
               )
               |> Repo.insert()

      assert {"has already been taken", _} = errors[:code_challenge]
    end

    test "requires open_id_nonce to be unique" do
      nonce = "nonce!"
      %{application: app} = Fixtures.insert(:access_grant, open_id_nonce: nonce)

      assert {:error, %Changeset{errors: errors}} =
               :access_grant
               |> Fixtures.build()
               |> AccessGrant.changeset(
                 %{open_id_nonce: nonce},
                 app,
                 opt_app: :zoth
               )
               |> Repo.insert()

      assert {"has already been taken", _} = errors[:open_id_nonce]
    end
  end
end
